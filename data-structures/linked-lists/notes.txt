Linked Lists

Linked Lists are a linear data structure, but elements are not stored at a contiguous location; the elements are linked using pointers.

Why Linked List?
1.) Dynamic size
2.) Ease of insertion/deletion

Drawbacks
1.) Random access is not allowed. Must always begin at the first node.
2.) Extra mnemory space for a pointer is required with each element of the list.
3.) Not cache friendly, locality of reference is not present.

Representation
- Represented by a pointer to the first node of the linked list. 
- The first node is called the head.
- If empty, the head points to NULL.
- Each node:
    1.) data (can store any type of data)
    2.) pointer (reference) to the next node (connects one node to another)
    3.) Example:
        ```c++
            class Node {
                public:
                    int data;
                    Node* next;
            };
        ```

        ```python
            # Node class
            class Node:
                # Function to initialize the node object
                def __init__(self, data):
                    self.data = data # assign data
                    self.next = None # Initialize next as NULL

            # Linked List class
            class LinkedList:
                #Function to initialize the Linked List object
                def __init__(self):
                    self.head = None
        ```

A node can be added into a linked list in 3 different ways:
1.) At the front of the linked list.
    ```c++
        /* Given a reference (pointer to pointer) to the head of a list and an int, inserts a new node on the fronmt of the list */
        // Time complexity: O(1) as it does a constant amount of work
        void push(Node** head_ref, int new_data) {
            // 1. allocate the new node 
            Node* new_node = new Node();
            // 2. put in the data
            new_node->data = new_data;
            // 3. make next of new node as head
            new_node->next = (*head_ref)
            // 4. move the head to point to the new node
            (*head_ref) = new_node
        }
    ```
2.) After a given node.
    ```c++
        /* Given a node prev_node, insert a new node after the given prev_node */
        // Time complexity: O(1) as it does a constant amount of work
        void insertAfter(Node* prev_node, int new_data) {
            // 1.) Check if the given prev_node is NULL
            if (prev_node == NULL) {
                cout << "The given previous node cannot be NULL";
                return;
            }
            // 2.) allocate the new node
            Node* new_node = new Node();
            // 3.) Put in the data
            new_node->data = new_data;
            // 4.) Make next of new node as next of prev_node
            new_node->next = prev_node->next;
            // 5.) move the next of prev_node as new_node
            prev_node->next = new_node;
        }
    ```
3.) At the end of the linked list.
    ```c++
        /* Given a reference (pointer to pointer) to the head of a list and an int, appends a new node at the end */
        // Time complexity: O(n) but can be optimized to O(1) by keep an extra pointer for the tail of the linked list
        void append(Node** head_ref, int new_data) {
            // 1. allocate node
            Node* new_node = new Node()
            // 2. Put in the data
            new_node->data = new_data;
            // 3. This new node is going to be the last node, so make next of it as NULL
            new_node->next = NULL;
            // 4. If the linked list is empty, then make the new node as head
            if (*head_ref == NULL) {
                *head_ref = new_node;
                return;
            }
            // 5. Else traverse till the last node
            Node* last = *head_ref;
            while (last->next != NULL) {
                last = last->next;
            }
            // 6. Change the next of last node
            last->next = new_node;
            return;
        }
    ```